#!/usr/bin/env python
<<<<<<< HEAD
""" pygame.examples.setmodescale
=======
"""pygame.examples.setmodescale
>>>>>>> 705f30d050018b014a6053acce19a31da360c7ed

On high resolution displays(4k, 1080p) and tiny graphics games (640x480)
show up very small so that they are unplayable. SCALED scales up the window
for you. The game thinks it's a 640x480 window, but really it can be bigger.
Mouse events are scaled for you, so your game doesn't need to do it.

Passing SCALED to pygame.display.set_mode means the resolution depends
on desktop size and the graphics are scaled.
"""

<<<<<<< HEAD
import pygame as pg

pg.init()

RES = (160, 120)
FPS = 30
clock = pg.time.Clock()

print("desktops", pg.display.get_desktop_sizes())
screen = pg.display.set_mode(RES, pg.SCALED | pg.RESIZABLE)
=======
import pygame
import sys

pygame.init()

RES = (160, 120)
FPS = 30
clock = pygame.Clock()

print("desktops", pygame.display.get_desktop_sizes())

do_vsync = bool("--vsync" in sys.argv)

if do_vsync:
    screen = pygame.display.set_mode(RES, pygame.SCALED | pygame.RESIZABLE, vsync=1)
else:
    screen = pygame.display.set_mode(RES, pygame.SCALED | pygame.RESIZABLE)
>>>>>>> 705f30d050018b014a6053acce19a31da360c7ed

# MAIN LOOP

done = False

i = 0
j = 0

<<<<<<< HEAD
r_name, r_flags = pg.display._get_renderer_info()
=======
r_name, r_flags = pygame.display._get_renderer_info()
>>>>>>> 705f30d050018b014a6053acce19a31da360c7ed
print("renderer:", r_name, "flags:", bin(r_flags))
for flag, name in [
    (1, "software"),
    (2, "accelerated"),
    (4, "VSync"),
    (8, "render to texture"),
]:
    if flag & r_flags:
        print(name)

while not done:
<<<<<<< HEAD
    for event in pg.event.get():
        if event.type == pg.KEYDOWN and event.key == pg.K_q:
            done = True
        if event.type == pg.QUIT:
            done = True
        if event.type == pg.KEYDOWN and event.key == pg.K_f:
            pg.display.toggle_fullscreen()
        if event.type == pg.VIDEORESIZE:
            pg.display._resize_event(event)

=======
    for event in pygame.event.get():
        if event.type == pygame.KEYDOWN and event.key == pygame.K_q:
            done = True
        if event.type == pygame.QUIT:
            done = True
        if event.type == pygame.KEYDOWN and event.key == pygame.K_f:
            pygame.display.toggle_fullscreen()
>>>>>>> 705f30d050018b014a6053acce19a31da360c7ed
    i += 1
    i = i % screen.get_width()
    j += i % 2
    j = j % screen.get_height()

    screen.fill((255, 0, 255))
<<<<<<< HEAD
    pg.draw.circle(screen, (0, 0, 0), (100, 100), 20)
    pg.draw.circle(screen, (0, 0, 200), (0, 0), 10)
    pg.draw.circle(screen, (200, 0, 0), (160, 120), 30)
    pg.draw.line(screen, (250, 250, 0), (0, 120), (160, 0))
    pg.draw.circle(screen, (255, 255, 255), (i, j), 5)

    pg.display.flip()
    clock.tick(FPS)
pg.quit()
=======
    pygame.draw.circle(screen, (0, 0, 0), (100, 100), 20)
    pygame.draw.circle(screen, (0, 0, 200), (0, 0), 10)
    pygame.draw.circle(screen, (200, 0, 0), (160, 120), 30)
    if do_vsync:
        # vertical line that moves horizontally to make screen tearing obvious
        pygame.draw.line(screen, (250, 250, 0), (i, 0), (i, 120))
    else:
        pygame.draw.line(screen, (250, 250, 0), (0, 120), (160, 0))
    pygame.draw.circle(screen, (255, 255, 255), (i, j), 5)

    pygame.display.set_caption("FPS:" + str(clock.get_fps()))
    if do_vsync:
        pygame.display.flip()
        # FPS should be limited by vsync, so we tick really fast
        # we only need to have the clock tick to track FPS
        clock.tick()
    else:
        clock.tick(FPS)
        pygame.display.flip()

pygame.quit()
>>>>>>> 705f30d050018b014a6053acce19a31da360c7ed
