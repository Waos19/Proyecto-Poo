#!/usr/bin/env python
<<<<<<< HEAD
""" pg.examples.video
=======
"""pygame.examples.video
>>>>>>> 705f30d050018b014a6053acce19a31da360c7ed

Experimental!

* dialog message boxes with messagebox.
* multiple windows with Window
* driver selection
* Renderer, Texture, and Image classes
* Drawing lines, rects, and such onto Renderers.
"""
<<<<<<< HEAD
import os
import pygame as pg
from pygame._sdl2 import Window, Texture, Image, Renderer, get_drivers, messagebox
=======

import os
import pygame

from pygame._sdl2 import Window, Texture, Image, Renderer, get_drivers
>>>>>>> 705f30d050018b014a6053acce19a31da360c7ed

data_dir = os.path.join(os.path.split(os.path.abspath(__file__))[0], "data")


def load_img(file):
<<<<<<< HEAD
    return pg.image.load(os.path.join(data_dir, file))


pg.display.init()
pg.key.set_repeat(1000, 10)
=======
    return pygame.image.load(os.path.join(data_dir, file))


pygame.display.init()
pygame.key.set_repeat(1000, 10)
>>>>>>> 705f30d050018b014a6053acce19a31da360c7ed

for driver in get_drivers():
    print(driver)

import random

<<<<<<< HEAD
try:
    answer = messagebox(
        "I will open two windows! Continue?",
        "Hello!",
        info=True,
        buttons=("Yes", "No", "Chance"),
        return_button=0,
        escape_button=1,
    )
    if answer == 1 or (answer == 2 and random.random() < 0.5):
        import sys

        sys.exit(0)
except:
    pass
=======
answer = pygame.display.message_box(
    "I will open two windows! Continue?",
    "Hello!",
    message_type="info",
    buttons=("Yes", "No", "Chance"),
    return_button=0,
    escape_button=1,
)

if answer == 1 or (answer == 2 and random.random() < 0.5):
    import sys

    sys.exit(0)
>>>>>>> 705f30d050018b014a6053acce19a31da360c7ed

win = Window("asdf", resizable=True)
renderer = Renderer(win)
tex = Texture.from_surface(renderer, load_img("alien1.gif"))
<<<<<<< HEAD
img = Image(tex)
=======
>>>>>>> 705f30d050018b014a6053acce19a31da360c7ed

running = True

x, y = 250, 50
<<<<<<< HEAD
clock = pg.time.Clock()
=======
clock = pygame.Clock()
>>>>>>> 705f30d050018b014a6053acce19a31da360c7ed

backgrounds = [(255, 0, 0, 255), (0, 255, 0, 255), (0, 0, 255, 255)]
bg_index = 0

renderer.draw_color = backgrounds[bg_index]

win2 = Window("2nd window", size=(256, 256), always_on_top=True)
win2.opacity = 0.5
win2.set_icon(load_img("bomb.gif"))
renderer2 = Renderer(win2)
tex2 = Texture.from_surface(renderer2, load_img("asprite.bmp"))
renderer2.clear()
tex2.draw()
renderer2.present()
del tex2

full = 0

<<<<<<< HEAD
surf = pg.Surface((64, 64))
streamtex = Texture(renderer, (64, 64), streaming=True)
tex_update_interval = 1000
next_tex_update = pg.time.get_ticks()


while running:
    for event in pg.event.get():
        if event.type == pg.QUIT:
            running = False
        elif getattr(event, "window", None) == win2:
            if (
                event.type == pg.KEYDOWN
                and event.key == pg.K_ESCAPE
                or event.type == pg.WINDOWCLOSE
            ):
                win2.destroy()
        elif event.type == pg.KEYDOWN:
            if event.key == pg.K_ESCAPE:
                running = False
            elif event.key == pg.K_LEFT:
                x -= 5
            elif event.key == pg.K_RIGHT:
                x += 5
            elif event.key == pg.K_DOWN:
                y += 5
            elif event.key == pg.K_UP:
                y -= 5
            elif event.key == pg.K_f:
=======
tex = Image(tex)


surf = pygame.Surface((64, 64))
streamtex = Texture(renderer, (64, 64), streaming=True)
tex_update_interval = 1000
next_tex_update = pygame.time.get_ticks()


while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif getattr(event, "window", None) == win2:
            if (
                event.type == pygame.KEYDOWN
                and event.key == pygame.K_ESCAPE
                or event.type == pygame.WINDOWCLOSE
            ):
                win2.destroy()
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                running = False
            elif event.key == pygame.K_LEFT:
                x -= 5
            elif event.key == pygame.K_RIGHT:
                x += 5
            elif event.key == pygame.K_DOWN:
                y += 5
            elif event.key == pygame.K_UP:
                y -= 5
            elif event.key == pygame.K_f:
>>>>>>> 705f30d050018b014a6053acce19a31da360c7ed
                if full == 0:
                    win.set_fullscreen(True)
                    full = 1
                else:
                    win.set_windowed()
                    full = 0
<<<<<<< HEAD
            elif event.key == pg.K_s:
                readsurf = renderer.to_surface()
                pg.image.save(readsurf, "test.png")

            elif event.key == pg.K_SPACE:
=======
            elif event.key == pygame.K_s:
                readsurf = renderer.to_surface()
                pygame.image.save(readsurf, "test.png")

            elif event.key == pygame.K_SPACE:
>>>>>>> 705f30d050018b014a6053acce19a31da360c7ed
                bg_index = (bg_index + 1) % len(backgrounds)
                renderer.draw_color = backgrounds[bg_index]

    renderer.clear()

    # update texture
<<<<<<< HEAD
    curtime = pg.time.get_ticks()
=======
    curtime = pygame.time.get_ticks()
>>>>>>> 705f30d050018b014a6053acce19a31da360c7ed
    if curtime >= next_tex_update:
        for x_ in range(streamtex.width // 4):
            for y_ in range(streamtex.height // 4):
                newcol = (
                    random.randint(0, 255),
                    random.randint(0, 255),
                    random.randint(0, 255),
                    255,
                )
                area = (4 * x_, 4 * y_, 4, 4)
                surf.fill(newcol, area)
        streamtex.update(surf)
        next_tex_update = curtime + tex_update_interval
<<<<<<< HEAD
    streamtex.draw(dstrect=pg.Rect(64, 128, 64, 64))

    img.draw(dstrect=(x, y))
=======
    streamtex.draw(dstrect=pygame.Rect(64, 128, 64, 64))

    tex.draw(dstrect=(x, y))
>>>>>>> 705f30d050018b014a6053acce19a31da360c7ed

    # TODO: should these be?
    # - line instead of draw_line
    # - point instead of draw_point
    # - rect(rect, width=1)->draw 1 pixel, instead of draw_rect
    # - rect(rect, width=0)->filled ? , instead of fill_rect
    #
<<<<<<< HEAD
    # TODO: should these work with pg.draw.line(renderer, ...) functions?
=======
    # TODO: should these work with pygame.draw.line(renderer, ...) functions?
>>>>>>> 705f30d050018b014a6053acce19a31da360c7ed
    renderer.draw_color = (255, 255, 255, 255)
    renderer.draw_line((0, 0), (64, 64))
    renderer.draw_line((64, 64), (128, 0))
    renderer.draw_point((72, 32))
<<<<<<< HEAD
    renderer.draw_rect(pg.Rect(0, 64, 64, 64))
    renderer.fill_rect(pg.Rect(0, 128, 64, 64))
=======
    renderer.draw_rect(pygame.Rect(0, 64, 64, 64))
    renderer.fill_rect(pygame.Rect(0, 128, 64, 64))
>>>>>>> 705f30d050018b014a6053acce19a31da360c7ed
    renderer.draw_color = backgrounds[bg_index]

    renderer.present()

    clock.tick(60)
    win.title = str(f"FPS: {clock.get_fps()}")

<<<<<<< HEAD
pg.quit()
=======
pygame.quit()
>>>>>>> 705f30d050018b014a6053acce19a31da360c7ed
